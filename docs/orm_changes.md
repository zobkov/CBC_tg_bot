1. **Подготовка конфигурации SQLAlchemy**  
   - Вынести параметры подключения и размеров пула в единый конфиг, переиспользуя логику `config.load_config`.  
   - Создать модуль инициализации (например, `app/infrastructure/database/sqlalchemy.py`) с `AsyncEngine`, `async_sessionmaker`, логгером и метриками.  
   - Заменить текущее построение пула в `infrastructure.database.connect_to_pg.get_pg_pool` на ленивую инициализацию движка; обеспечить единичный инстанс на приложение.

2. **Описать декларативные модели**  
   - Перенести структуры из models в SQLAlchemy `DeclarativeBase`, указав типы, ключи и связи.  
   - Сопоставить модели со схемой миграций (учесть пропущенные поля вроде `approved`).  
   - Добавить вспомогательные датаклассы/`TypedDict`, если требуется отдавать облегчённые DTO наружу.

3. **Репозитории на Core/ORM**  
   - Создать слой репозиториев, который инкапсулирует CRUD и сложные запросы.  
   - Перевести текущие DAO (например, `dao/feedback.py`) и хранилища (`database/users.py`, `task_statistics.py`) на работу через `AsyncSession`.  
   - Внедрить стандартные методы (`get`, `list`, `upsert`) и йисключить прямой `psycopg`.

4. **Переписывание бизнес-операций на сессии**  
   - Использовать `async with session.begin()` в сценариях вроде бронирования слотов и обновления статусов.  
   - Реализовать UPSERT через `sqlalchemy.dialects.postgresql.insert(...).on_conflict_do_update/do_nothing`.  
   - Добавить блокировки `select_for_update()` для последовательностей «прочитал → изменил».

5. **Оптимизация сервисов (broadcast, Google sync)**  
   - `services.broadcast_scheduler` перевести на пакетные запросы через одну сессию; отказаться от множества открытий коннекта.  
   - `services.google_sync_service.GoogleSyncService` использовать репозитории вместо RAW SQL, объединяя выборки и обновления в транзакции.  
   - Проверить все фоновые задачи на предмет батчевых операций.

6. **Разделение слоёв и зависимостей**  
   - Убрать загрузку конфигов внутри DAO (`load_config()` по умолчанию) и передавать зависимости через конструкторы сервисов.  
   - Оставить в репозиториях только доступ к данным; форматирование ответов перенести в сервисные классы и обработчики (например, в бот-диалогах).  
   - Настроить DI/фабрики, чтобы контролировать жизненный цикл сессий.

7. **Единый контракт возвращаемых типов**  
   - Определить, где возврат идёт ORM-моделями, где DTO; заполнить поля сериализаторами/mapper’ами.  
   - Настроить `session.execute(...).mappings()` или ORM для получения словарей, чтобы заменить ручную распаковку в `dao`.  
   - Обновить сервисы и ботов на использование новых структур.

8. **Наблюдаемость и профилирование**  
   - Подключить события SQLAlchemy (`event.listens_for(Engine, "after_cursor_execute")`) для логирования длительности и ошибок.  
   - Отправлять метрики в существующую систему мониторинга или добавить Prometheus-экспорт.  
   - Перенести текущее точечное логирование (успешные сообщения) в структурированные логи.

9. **Тестирование**  
   - Написать интеграционные тесты для репозиториев с использованием тестовой БД/фикстур.  
   - Покрыть критические сценарии (запись статистики, выдача ролей, синхронизация заявок) регрессионными тестами.  
   - Обновить существующие unit-тесты под новый интерфейс (если есть).

10. **Документация и скрипты**  
   - Обновить `README` и служебные скрипты из `scripts`, показав, как получать сессию/движок.  
   - Добавить инструкции по миграции (проверка Alembic, если планируется).  
   - Внести изменения в CLI/утилиты, которые сейчас напрямую используют `psycopg` (например, отчёты и рассылки), чтобы они получали сессию из нового модуля.

Каждый пункт устраняет текущие проблемы: устаревшее управление пулом, риск инъекций, гонки, лишние подключения и смешение слоёв. SQLAlchemy даст централизованный контроль соединений, безопасную генерацию SQL, транзакции и удобное сопровождение.